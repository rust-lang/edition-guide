<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Path clarity - The Edition Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../../introduction.html">Introduction</a></li><li><a href="../../editions/index.html"><strong aria-hidden="true">1.</strong> What are editions?</a></li><li><ol class="section"><li><a href="../../editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> Creating a new project</a></li><li><a href="../../editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> Transitioning an existing project to a new edition</a></li></ol></li><li><a href="../../rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li><a href="../../rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li><a href="../../rust-2018/edition-changes.html"><strong aria-hidden="true">3.1.</strong> 2018-Specific Changes</a></li><li><a href="../../rust-2018/module-system/index.html"><strong aria-hidden="true">3.2.</strong> Module system</a></li><li><ol class="section"><li><a href="../../rust-2018/module-system/raw-identifiers.html"><strong aria-hidden="true">3.2.1.</strong> Raw identifiers</a></li><li><a href="../../rust-2018/module-system/path-clarity.html" class="active"><strong aria-hidden="true">3.2.2.</strong> Path clarity</a></li><li><a href="../../rust-2018/module-system/more-visibility-modifiers.html"><strong aria-hidden="true">3.2.3.</strong> More visibility modifiers</a></li><li><a href="../../rust-2018/module-system/nested-imports-with-use.html"><strong aria-hidden="true">3.2.4.</strong> Nested imports with use</a></li></ol></li><li><a href="../../rust-2018/error-handling-and-panics/index.html"><strong aria-hidden="true">3.3.</strong> Error handling and panics</a></li><li><ol class="section"><li><a href="../../rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><strong aria-hidden="true">3.3.1.</strong> The ? operator for easier error handling</a></li><li><a href="../../rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html"><strong aria-hidden="true">3.3.2.</strong> ? in main and tests</a></li><li><a href="../../rust-2018/error-handling-and-panics/controlling-panics-with-std-panic.html"><strong aria-hidden="true">3.3.3.</strong> Controlling panics with std::panic</a></li><li><a href="../../rust-2018/error-handling-and-panics/aborting-on-panic.html"><strong aria-hidden="true">3.3.4.</strong> Aborting on panic</a></li></ol></li><li><a href="../../rust-2018/control-flow/index.html"><strong aria-hidden="true">3.4.</strong> Control flow</a></li><li><ol class="section"><li><a href="../../rust-2018/control-flow/loops-can-break-with-a-value.html"><strong aria-hidden="true">3.4.1.</strong> Loops can break with a value</a></li><li><a href="../../rust-2018/control-flow/async-await-for-easier-concurrency.html"><strong aria-hidden="true">3.4.2.</strong> async/await for easier concurrency</a></li></ol></li><li><a href="../../rust-2018/trait-system/index.html"><strong aria-hidden="true">3.5.</strong> Trait system</a></li><li><ol class="section"><li><a href="../../rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><strong aria-hidden="true">3.5.1.</strong> impl Trait for returning complex types with ease</a></li><li><a href="../../rust-2018/trait-system/dyn-trait-for-trait-objects.html"><strong aria-hidden="true">3.5.2.</strong> dyn Trait for trait objects</a></li><li><a href="../../rust-2018/trait-system/more-container-types-support-trait-objects.html"><strong aria-hidden="true">3.5.3.</strong> More container types support trait objects</a></li><li><a href="../../rust-2018/trait-system/associated-constants.html"><strong aria-hidden="true">3.5.4.</strong> Associated constants</a></li><li><a href="../../rust-2018/trait-system/no-anon-params.html"><strong aria-hidden="true">3.5.5.</strong> No more anonymous parameters</a></li></ol></li><li><a href="../../rust-2018/slice-patterns.html"><strong aria-hidden="true">3.6.</strong> Slice patterns</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/index.html"><strong aria-hidden="true">3.7.</strong> Ownership and lifetimes</a></li><li><ol class="section"><li><a href="../../rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"><strong aria-hidden="true">3.7.1.</strong> Non-lexical lifetimes</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/default-match-bindings.html"><strong aria-hidden="true">3.7.2.</strong> Default match bindings</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html"><strong aria-hidden="true">3.7.3.</strong> '_, the anonymous lifetime</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/lifetime-elision-in-impl.html"><strong aria-hidden="true">3.7.4.</strong> Lifetime elision in impl</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/inference-in-structs.html"><strong aria-hidden="true">3.7.5.</strong> T: 'a inference in structs</a></li><li><a href="../../rust-2018/ownership-and-lifetimes/simpler-lifetimes-in-static-and-const.html"><strong aria-hidden="true">3.7.6.</strong> Simpler lifetimes in static and const</a></li></ol></li><li><a href="../../rust-2018/data-types/index.html"><strong aria-hidden="true">3.8.</strong> Data types</a></li><li><ol class="section"><li><a href="../../rust-2018/data-types/field-init-shorthand.html"><strong aria-hidden="true">3.8.1.</strong> Field init shorthand</a></li><li><a href="../../rust-2018/data-types/inclusive-ranges.html"><strong aria-hidden="true">3.8.2.</strong> ..= for inclusive ranges</a></li><li><a href="../../rust-2018/data-types/128-bit-integers.html"><strong aria-hidden="true">3.8.3.</strong> 128 bit integers</a></li><li><a href="../../rust-2018/data-types/operator-equals-are-now-implementable.html"><strong aria-hidden="true">3.8.4.</strong> &quot;Operator-equals&quot; are now implementable</a></li><li><a href="../../rust-2018/data-types/union-for-an-unsafe-form-of-enum.html"><strong aria-hidden="true">3.8.5.</strong> union for an unsafe form of enum</a></li><li><a href="../../rust-2018/data-types/choosing-alignment-with-the-repr-attribute.html"><strong aria-hidden="true">3.8.6.</strong> Choosing alignment with the repr attribute</a></li></ol></li><li><a href="../../rust-2018/simd-for-faster-computing.html"><strong aria-hidden="true">3.9.</strong> SIMD for faster computing</a></li><li><a href="../../rust-2018/macros/index.html"><strong aria-hidden="true">3.10.</strong> Macros</a></li><li><ol class="section"><li><a href="../../rust-2018/macros/custom-derive.html"><strong aria-hidden="true">3.10.1.</strong> Custom Derive</a></li><li><a href="../../rust-2018/macros/macro-changes.html"><strong aria-hidden="true">3.10.2.</strong> Macro changes</a></li><li><a href="../../rust-2018/macros/at-most-once.html"><strong aria-hidden="true">3.10.3.</strong> At most one repetition</a></li></ol></li><li><a href="../../rust-2018/the-compiler/index.html"><strong aria-hidden="true">3.11.</strong> The compiler</a></li><li><ol class="section"><li><a href="../../rust-2018/the-compiler/improved-error-messages.html"><strong aria-hidden="true">3.11.1.</strong> Improved error messages</a></li><li><a href="../../rust-2018/the-compiler/incremental-compilation-for-faster-compiles.html"><strong aria-hidden="true">3.11.2.</strong> Incremental Compilation for faster compiles</a></li><li><a href="../../rust-2018/the-compiler/an-attribute-for-deprecation.html"><strong aria-hidden="true">3.11.3.</strong> An attribute for deprecation</a></li></ol></li><li><a href="../../rust-2018/rustup-for-managing-rust-versions.html"><strong aria-hidden="true">3.12.</strong> Rustup for managing Rust versions</a></li><li><a href="../../rust-2018/cargo-and-crates-io/index.html"><strong aria-hidden="true">3.13.</strong> Cargo and crates.io</a></li><li><ol class="section"><li><a href="../../rust-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><strong aria-hidden="true">3.13.1.</strong> cargo check for faster checking</a></li><li><a href="../../rust-2018/cargo-and-crates-io/cargo-install-for-easy-installation-of-tools.html"><strong aria-hidden="true">3.13.2.</strong> cargo install for easy installation of tools</a></li><li><a href="../../rust-2018/cargo-and-crates-io/cargo-new-defaults-to-a-binary-project.html"><strong aria-hidden="true">3.13.3.</strong> cargo new defaults to a binary project</a></li><li><a href="../../rust-2018/cargo-and-crates-io/cargo-rustc-for-passing-arbitrary-flags-to-rustc.html"><strong aria-hidden="true">3.13.4.</strong> cargo rustc for passing arbitrary flags to rustc</a></li><li><a href="../../rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html"><strong aria-hidden="true">3.13.5.</strong> Cargo workspaces for multi-package projects</a></li><li><a href="../../rust-2018/cargo-and-crates-io/multi-file-examples.html"><strong aria-hidden="true">3.13.6.</strong> Multi-file examples</a></li><li><a href="../../rust-2018/cargo-and-crates-io/replacing-dependencies-with-patch.html"><strong aria-hidden="true">3.13.7.</strong> Replacing dependencies with patch</a></li><li><a href="../../rust-2018/cargo-and-crates-io/cargo-can-use-a-local-registry-replacement.html"><strong aria-hidden="true">3.13.8.</strong> Cargo can use a local registry replacement</a></li><li><a href="../../rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html"><strong aria-hidden="true">3.13.9.</strong> Crates.io disallows wildcard dependencies</a></li></ol></li><li><a href="../../rust-2018/documentation/index.html"><strong aria-hidden="true">3.14.</strong> Documentation</a></li><li><ol class="section"><li><a href="../../rust-2018/documentation/new-editions-of-the-book.html"><strong aria-hidden="true">3.14.1.</strong> New editions of the &quot;the book&quot;</a></li><li><a href="../../rust-2018/documentation/the-rust-bookshelf.html"><strong aria-hidden="true">3.14.2.</strong> The Rust Bookshelf</a></li><li><a href="../../rust-2018/documentation/the-rustonomicon.html"><strong aria-hidden="true">3.14.3.</strong> The Rustonomicon</a></li><li><a href="../../rust-2018/documentation/std-os-has-documentation-for-all-platforms.html"><strong aria-hidden="true">3.14.4.</strong> Full documentation for std::os</a></li></ol></li><li><a href="../../rust-2018/rustdoc/index.html"><strong aria-hidden="true">3.15.</strong> rustdoc</a></li><li><ol class="section"><li><a href="../../rust-2018/rustdoc/documentation-tests-can-now-compile-fail.html"><strong aria-hidden="true">3.15.1.</strong> Documentation tests can now compile-fail</a></li><li><a href="../../rust-2018/rustdoc/rustdoc-uses-commonmark.html"><strong aria-hidden="true">3.15.2.</strong> Rustdoc uses CommonMark</a></li></ol></li><li><a href="../../rust-2018/platform-and-target-support/index.html"><strong aria-hidden="true">3.16.</strong> Platform and target support</a></li><li><ol class="section"><li><a href="../../rust-2018/platform-and-target-support/libcore-for-low-level-rust.html"><strong aria-hidden="true">3.16.1.</strong> libcore for low-level Rust</a></li><li><a href="../../rust-2018/platform-and-target-support/webassembly-support.html"><strong aria-hidden="true">3.16.2.</strong> WebAssembly support</a></li><li><a href="../../rust-2018/platform-and-target-support/global-allocators.html"><strong aria-hidden="true">3.16.3.</strong> Global allocators</a></li><li><a href="../../rust-2018/platform-and-target-support/msvc-toolchain-support.html"><strong aria-hidden="true">3.16.4.</strong> MSVC toolchain support</a></li><li><a href="../../rust-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html"><strong aria-hidden="true">3.16.5.</strong> MUSL support for fully static binaries</a></li><li><a href="../../rust-2018/platform-and-target-support/cdylib-crates-for-c-interoperability.html"><strong aria-hidden="true">3.16.6.</strong> cdylib crates for C interoperability</a></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Edition Guide</h1> 

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#path-clarity" id="path-clarity"><h1>Path clarity</h1></a>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" />
<img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /> for &quot;uniform paths&quot;</p>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Absolute paths begin with a crate name, where the keyword <code>crate</code>
refers to the current crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<blockquote>
<p>Additionally, in nightly, there's an additional possible tweak to paths
called &quot;Uniform paths&quot;. This is backwards compatible with the new path
changes. Uniform paths have a dedicated section at the end of this guide.</p>
</blockquote>
<a class="header" href="#more-details" id="more-details"><h2>More details</h2></a>
<p>Let's talk about each new feature in turn.</p>
<a class="header" href="#no-more-extern-crate" id="no-more-extern-crate"><h3>No more <code>extern crate</code></h3></a>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<blockquote>
<p>One small note here: <code>cargo fix</code> will not currently automate this change. We may
have it do this for you in the future.</p>
</blockquote>
<a class="header" href="#an-exception" id="an-exception"><h4>An exception</h4></a>
<p>There's one exception to this rule, and that's the &quot;sysroot&quot; crates. These are the
crates distributed with Rust itself. We'd eventually like to remove the requirement
for <code>extern crate</code> for them as well, but it hasn't shipped yet.</p>
<p>You'll need to use <code>extern crate</code> for:</p>
<ul>
<li><code>proc_macro</code></li>
</ul>
<p>Additionally, you would need to use it for:</p>
<ul>
<li><code>core</code></li>
<li><code>std</code></li>
</ul>
<p>However, <code>extern crate std;</code> is already implicit, and with <code>#![no_std]</code>,
<code>extern crate core;</code> is already implicit. You'll only need these in highly
specialized situations.</p>
<p>Finally, on nightly, you'll need it for crates like:</p>
<ul>
<li><code>alloc</code></li>
<li><code>test</code></li>
</ul>
<a class="header" href="#macros" id="macros"><h4>Macros</h4></a>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Check <a href="rust-2018/macros/macro-changes.html">the macro section</a> for more.</p>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;
</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;
</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<a class="header" href="#the-crate-keyword-refers-to-the-current-crate" id="the-crate-keyword-refers-to-the-current-crate"><h3>The <code>crate</code> keyword refers to the current crate.</h3></a>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<a class="header" href="#changes-to-paths" id="changes-to-paths"><h3>Changes to paths</h3></a>
<p>In Rust 2018, paths in <code>use</code> declarations <em>must</em> begin with a crate name,
<code>crate</code>, <code>self</code>, or <code>super</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;
</code></pre>
<p>Now looks like this:</p>
<pre><code class="language-rust ignore">// Rust 2018

// 'futures' is the name of a crate
use futures::Future;

mod foo {
    pub struct Bar;
}

// 'crate' means the current crate
use crate::foo::Bar;
</code></pre>
<p>In addition, all of these path forms are available outside of <code>use</code>
declarations as well, which eliminates many sources of confusion. Consider
this code in Rust 2015:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    // this works!
    use futures::Future;

    // so why doesn't this work?
    fn my_poll() -&gt; futures::Poll { ... }
}

fn main() {
    // this works
    let five = std::sync::Arc::new(5);
}

mod submodule {
    fn function() {
        // ... so why doesn't this work
        let five = std::sync::Arc::new(5);
    }
}
</code></pre>
<blockquote>
<p>In real code, you couldn't repeat <code>mod submodule</code>, and <code>function</code> would be defined
in the first <code>mod</code> block.</p>
</blockquote>
<p>In the <code>futures</code> example, the <code>my_poll</code> function signature is incorrect,
because <code>submodule</code> contains no items named <code>futures</code>; that is, this path is
considered relative. <code>use futures::</code> works even though a lone <code>futures::</code>
doesn't! With <code>std</code> it can be even more confusing, as you never wrote the
<code>extern crate std;</code> line at all. So why does it work in <code>main</code> but not in a
submodule? Same thing: it's a relative path because it's not in a <code>use</code>
declaration. <code>extern crate std;</code> is inserted at the crate root, so it's fine
in <code>main</code>, but it doesn't exist in the submodule at all.</p>
<p>Let's look at how this change affects things:</p>
<pre><code class="language-rust ignore">// Rust 2018

// no more `extern crate futures;`

mod submodule {
    // 'futures' is the name of a crate, so this works
    use futures::Future;

    // 'futures' is the name of a crate, so this works
    fn my_poll&lt;T, E&gt;() -&gt; futures::Poll {
        unimplemented!()
    }

    fn function() {
        // 'std' is the name of a crate, so this works
        let five = std::sync::Arc::new(5);
    }
}

fn main() {
    // 'std' is the name of a crate, so this works
    let five = std::sync::Arc::new(5);
}
</code></pre>
<p>Much more straightforward.</p>
<a class="header" href="#no-more-modrs" id="no-more-modrs"><h3>No more <code>mod.rs</code></h3></a>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">///  foo.rs 
///  or 
///  foo/mod.rs

mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018, <code>mod.rs</code> is no longer needed.</p>
<pre><code class="language-rust ignore">///  foo.rs 
///  foo/bar.rs

mod foo;

/// in foo.rs
mod bar;
</code></pre>
<p><code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<a class="header" href="#uniform-paths" id="uniform-paths"><h1>Uniform paths</h1></a>
<blockquote>
<p>Uniform paths are a nightly-only feature.</p>
</blockquote>
<p>The uniform paths variant of Rust 2018 simplifies and unifies path handling
compared to Rust 2015. In Rust 2015, paths work differently in <code>use</code>
declarations than they do elsewhere. In particular, paths in <code>use</code>
declarations would always start from the crate root, while paths in other code
implicitly started from the current module. Those differences didn't have any
effect in the top-level module, which meant that everything would seem
straightforward until working on a project large enough to have submodules.</p>
<p>In the uniform paths variant of Rust 2018, paths in <code>use</code> declarations and in
other code always work the same way, both in the top-level module and in any
submodule. You can always use a relative path from the current module, a path
starting from an external crate name, or a path starting with <code>crate</code>, <code>super</code>,
or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018 (uniform paths variant)

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>With uniform paths, however, the same code will also work completely unmodified in
a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018 (uniform paths variant)

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<p>If a path is ambiguous, such as if you have an external crate and a local
module or item with the same name, you'll get an error, and you'll need to
either rename one of the conflicting names or explicitly disambiguate the path.
To explicitly disambiguate a path, use <code>::name</code> for an external crate name, or
<code>self::name</code> for a local module or item.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../rust-2018/module-system/raw-identifiers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../rust-2018/module-system/more-visibility-modifiers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../rust-2018/module-system/raw-identifiers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../rust-2018/module-system/more-visibility-modifiers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
